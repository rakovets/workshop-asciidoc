= Основные понятия SQL

*SQL* - это язык структурированных запросов, с помощью которого можно обрабатывать и извлекать данные из реляционных баз данных.

Каждая строка, находящаяся в таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют *ключом*. Столбцы таблицы имеют атрибуты данных, а каждая запись обычно содержит значение для каждого атрибута, что дает возможность легко устанавливать взаимосвязь между элементами данных.

==  Однострочные и многострочные комментарии

Комментарии используются для пояснения разделов операторов SQL или для предотвращения выполнения операторов во время отладки запросов.

=== Однострочные комментарии

Однострочные комментарии начинаются со знака `-`. Любой текст между `-` и концом строки будет проигнорирован (не будет выполнен).

В следующем примере в качестве объяснения используется однострочный комментарий:

[source,sql]
----
-- Select all:
SELECT * FROM users;
----

В следующем примере используется однострочный комментарий для игнорирования конца строки:

[source,sql]
----
SELECT * FROM users -- WHERE balance = 1000;
----

В следующем примере используется однострочный комментарий для игнорирования оператора:

[source,sql]
----
-- SELECT * FROM users
SELECT * FROM users;
----

=== Многострочные комментарии

Многострочные комментарии начинаются с `/` и заканчиваются на `/`. Любой текст между `/` и `/` будет проигнорирован. В следующем примере в качестве объяснения используется многострочный комментарий:

[source,sql]
----
/* Этот запрос
выведет данные
всех пользователей */

SELECT * FROM users;
----

В следующем примере используется многострочный комментарий для игнорирования многих операторов:

[source,sql]
----
/*SELECT * FROM users;
SELECT * FROM product;
SELECT * FROM invoice;*/

SELECT * FROM category;
----

== Базы данных

=== Оператор `CREATE DATABASE`

Оператор `CREATE DATABASE` используется для создания новой базы данных SQL.

*Синтаксис:*

[source,sql]
----
CREATE DATABASE databasename;
----

*Пример*, следующий оператор SQL создает базу данных с именем `invoice`:

[source,sql]
----
CREATE DATABASE invoice;
----

=== Оператор `DROP DATABASE`

Оператор `DROP DATABASE` используется для удаления существующей базы данных SQL.

*Синтаксис:*

[source,sql]
----
DROP DATABASE databasename;
----

*Пример*, следующий оператор SQL уничтожает существующую базу данных `info`:

[source,sql]
----
DROP DATABASE info;
----

== Типы данных

*Тип данных* — это атрибут, который определяет тип любого объекта. *SQL* предлагает шесть категорий типов данных для использования.

=== Точные типы числовых данных

|===
|Тип данных|Возможные значения|Примечание

|`bit`
|`0` или `1`
|Фактически является аналогом булевого типа в языках программирования. Занимает 1 байт.

|`TINYINT`
|От `0` до `255`
|Занимает 1 байт. Хорошо подходит для хранения небольших чисел.

|`SMALLINT`
|От `–32 768` до `32 767`
|Занимает 2 байта

|`INT`
|От `–2 147 483 648` до `2 147 483 647`
|Занимает 4 байта. Наиболее используемый тип для хранения чисел.

|`BIGINT`
|От `-9 223 372 036 854 775 808` до `9 223 372 036 854 775 807`
|Занимают в памяти 8 байт.

|`DECIMAL` 2+^|Хранит числа с фиксированной точностью. Занимает от 5 до 17 байт в зависимости от количества чисел после запятой. Данный тип может принимать два параметра `precision` и `scale`: `DECIMAL(precision, scale)`. Параметр `precision` представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от `1` до `38`. По умолчанию оно равно `18`. Параметр `scale` представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от `0` до значения параметра `precision`. По умолчанию оно равно `0`.

|`MONEY`
|Дробные значения от `-922 337 203 685 477.5808` до `922 337 203 685 477.5807`
|Представляет денежные величины и занимает 8 байт.

|`SMALLMONEY`
|Хранит дробные значения от `-214 748.3648` до `214 748.3647`
|Предназначено для хранения денежных величин. Занимает 4 байта. Эквивалентен типу `DECIMAL(10,4)`.

|`FLOAT`
|Хранит числа от `–1.79E+308` до `1.79E+308`
|Занимает от 4 до 8 байт в зависимости от дробной части.

|`REAL`
|От `–340E+38` to `3.40E+38`
|Занимает 4 байта. Эквивалентен типу `FLOAT(24)`.
|===

Если необходимо получать из базы данных числовое значение в строго указанном формате, то для этого следует выбрать один из точных числовых типов данных.

=== Примерные типы числовых данных

|===
|Тип данных|Возможные значения
|`float`|От `-1.79E + 308`, до `1.79E + 308`
|`real`|От `-3.40E + 38`, до `3.40E + 38`
|===

Некоторые числа нельзя точно представить в десятичном виде с ограниченным числом знаков, например, одну треть или число пи. Для записи таких чисел используются действительный (`real`) или плавающий (`float`) типы данных. Данные действительного типа хранятся с точностью от 1 до 7 знаков. Плавающий формат, который иногда называют еще форматом двойной точности, может хранить числа, содержащие от 8 до 15 значащих цифр. Действительный и плавающий типы данных применяются в научных приложениях для хранения чисел, не требующих точного двоичного выражения. Одна-две последние цифры могут не вполне точно сохраняться при преобразованиях в двоичный формат.

=== Типы данных даты и времени

|===
|Тип данных |Примечание
|`datetime`|От `1 января 1753`, до `31 декабря, 9999`
|`smalldatetime`|От `1 января 1900`, до `6 июня 2079`
|`date`|Сохраняет дату, как `30 июня 1991 года`
|`time`|Сохраняет время суток, как `12:30`

|===

Для дат применяются два типа данных, `datetime` и `smalldatetime`. Тип данных `smalldatetime` охватывает период времени от 1 января 1900 года до 6 июня 2079 года и включает время с точностью до минуты. Такого диапазона достаточно для подавляющего большинства проектов. Тип данных `datetime` годен для использования до 31 декабря 9999 года (это следует учитывать при решении проблемы 10К года).

=== Типы данных символьных строк

|===
|Тип данных|Возможные значения
|`char`|Максимальная длина 8000 символов.
(Фиксированная длина без Unicode символов)
|`varchar`| Максимум 8000 символов.
(Переменная длина данных не-Unicode).
|`text`|Переменная длина данных, не Unicode с максимальной длиной 2147483647 символов.
|===

К этому типу относятся такие символьные данные, как имена или адреса. Можно выбрать символьный тип данных либо фиксированной длины, `char`, либо переменной длины, `varchar`. Фиксированный размер оказывается предпочтительным в тех случаях, когда данные имеют одинаковую или сходную длину, например, при вводе идентификатора автора (часто в этом качестве используют индивидуальный номер системы социальной безопасности). В большинстве ситуаций применение переменной длины данных не приводит к сколько-нибудь заметному увеличению времени обработки. В то же время фамилия автора может быть очень длинной, так что использование типа `varchar` оказывается вполне оправданным. Применительно к подавляющему большинству фамилий фиксированная длина поля означает потерю значительного объема памяти, поэтому лучше использовать тип данных varchar. При выборе того или иного типа данных всегда следует искать компромисс с учетом двух аспектов: с одной стороны, потери полезного объема памяти при использовании данных фиксированной длины, а с другой стороны, увеличения времени обработки в случае применения данных переменной длины.

=== Типы строк данных символов Unicode

*Юникод* (англ. *Unicode*) — стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира.

|===
|Тип данных|Возможные значения
|`nchar`|Максимальная длина 4000 символов. (Фиксированная длина Unicode)
|`nvarchar`|Максимальная длина 4000 символов. (Переменная длина Unicode)
|`nvarchar(max)`|Максимальная длина 231 символов (SQL Server 2005). (Переменная длина Unicode)
|`ntext`|Максимальная длина 1,073,741,823 символа. (Переменная длина Unicode)
|===

SQL Server 7.0 поддерживает набор символов Unicode.
В связи с этим, чтобы воспользоваться всеми преимуществами, предоставляемыми расширенными возможностями Unicode, необходимо было ввести дополнительный тип данных. Если необходимо использовать символьные данные Unicode, то следует указать тип данных `Nchar` или, если это информация переменной длины, то `Nvarchar`. При вводе данных Unicode их следует заключать в одиночные кавычки, причем непосредственно перед ними необходимо поставить заглавную латинскую букву N. Ограничение максимальной длины информации при работе с типом данных Unicode составляет 4000 знаков. Это объясняется тем, что для хранения каждого символа Unicode требуется два байта памяти. Поэтому на стандартную страницу памяти размером 8К можно поместить в два раза меньше символов Unicode, чем при использовании обычных символов.

=== Двоичные типы данных

|===
|Тип данных|Возможные значения
|`binary`|Максимальная длина 8000 байт (фиксированная длина двоичных данных)
|`varbinary`|Максимальная длина 8000 байт.(Переменная длина двоичных данных)
|`varbinary(max)`|Максимальная длина 231 байт (SQL Server 2005).(Переменная длина двоичных данных)
|`image`|Максимальная длина 2147483647 байт.(Переменная длина двоичных данных)
|===

Если в базе данных необходимо хранить двоичную информацию, имеется выбор между двумя форматами представления: с фиксированной или переменной длиной. Данным фиксированной длины соответствует тип данных `binary`, а двоичным данным переменной длины соответствует тип данных `varbinary`.

== Таблицы

=== Создание таблицы `CREATE TABLE`

Для того чтобы создать таблицу в *SQL*, используется выражение `CREATE TABLE`. Оно принимает в качестве параметров все колонки, которые необходимо внести, а также их типы данных. Пример создания таблицы с названием `Months`, в которой будет три колонки:

* `id` - порядковый номер месяца (целочисленный тип или `int`).
* `name` - название месяца.
* `days` - число дней в конкретном месяце.

Код создания будет выглядеть следующим образом:

[source,sql]
----
CREATE TABLE months (id int, name varchar(10), days int);
----

=== Запрос `DROP TABLE`

Оператор `DROP TABLE` используется для удаления существующей таблицы в базе данных.

*Синтаксис:*

[source,sql]
----
DROP TABLE table_name;
----

=== Удаление таблиц при помощи `TRUNCATE`

Если необходимо все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду `TRUNCATE`:

[source,sql]
----
TRUNCATE TABLE table_name;
----

== Ограничения

*Ограничения* могут быть указаны при создании таблицы с помощью оператора `CREATE TABLE` или после создания таблицы с помощью инструкции `ALTER TABLE`.

*Синтаксис:*

[source,sql]
----
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);
----

*SQL-ограничения* используются для указания правил данных таблицы, для ограничения типа данных, которые могут входить в таблицу. Это обеспечивает точность и надежность данных в таблице. Если между ограничением и действием данных существует какое-либо нарушение, действие прерывается.

Ограничения могут быть уровнями столбцов или таблиц. Ограничения уровня столбца применяются к столбцу, а ограничения уровня таблиц относятся ко всей таблице.

В SQL обычно используются следующие ограничения:

* `NOT NULL` - гарантирует, что столбец не может иметь значение NULL
* `UNIQUE` - обеспечивает, чтобы все значения в столбце были разными
* `PRIMARY KEY` - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице
* `FOREIGN KEY` - однозначно идентифицирует строку / запись в другой таблице
* `CHECK` - обеспечивает, чтобы все значения в столбце удовлетворяли конкретному условию
* `DEFAULT` - устанавливает значение по умолчанию для столбца, если не указано значение
* `INDEX` - используется для быстрого создания и извлечения данных из базы данных

=== Ограничение `NOT NULL`

По умолчанию столбец может содержать значения `NULL`. Ограничение `NOT NULL` приводит к тому, что столбец НЕ принимает значения `NULL`. Это приводит к тому, что поле всегда содержит значение, а это означает, что нельзя вставить новую запись или обновить запись без добавления значения в это поле.

Следующий SQL-запрос гарантирует, что столбцы `user_id`, `name` и `fullname` НЕ будут принимать значения `NULL`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255) NOT NULL,
balanse int
);
----

=== Ограничение `UNIQUE`

Ограничение `UNIQUE` гарантирует, что все значения в столбце отличаются. Ограничения `UNIQUE` и `PRIMARY KEY` гарантируют уникальность столбца или набора столбцов. Ограничение `PRIMARY KEY` автоматически имеет ограничение `UNIQUE`.

Однако для каждой таблицы может быть множество ограничений `UNIQUE`, но только одно ограничение `PRIMARY KEY` для каждой таблицы.

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
UNIQUE (user_id)
);
----

====  Создание ограничения `UNIQUE` когда таблица уже создана

Чтобы создать ограничение `UNIQUE` в столбце `user_id`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD UNIQUE (user_id);
----

Чтобы назвать ограничение `UNIQUE` и определить ограничение `UNIQUE` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT UC_Users UNIQUE (user_id, name);
----

==== Удаление ограничения `UNIQUE`

Чтобы удалить ограничение `UNIQUE`, используйте следующий SQL-запрос:

[source,sql]
----
ALTER TABLE users
DROP INDEX UC_Users;
----

=== Ограничение `PRIMARY KEY`

Ограничение `PRIMARY KEY` однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать `UNIQUE` значения и не могут содержать значения `NULL`.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

==== Создание `PRIMARY KEY` при создании таблицы

Следующий SQL-запрос создает `PRIMARY KEY` в столбце `user_id`, когда создается таблица `users`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
PRIMARY KEY (user_id)
);
----

Чтобы разрешить именовать ограничение `PRIMARY KEY` и определить ограничение `PRIMARY KEY` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE users (
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    CONSTRAINT PK_Users PRIMARY KEY (user_id, name)
);
----

==== Создание ограничения `PRIMARY KEY` когда таблица уже создана

Чтобы создать ограничение `PRIMARY KEY` в столбце `user_id`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD PRIMARY KEY (user_id);
----

Чтобы разрешить именовать ограничение `PRIMARY `KEY` и определить ограничение `PRIMARY KEY` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT PK_Users PRIMARY KEY (user_id, name);
----

==== Удаление ограничения `PRIMARY KEY

Чтобы удалить ограничение `PRIMARY KEY`, используйте следующее:
[source,sql]
----
ALTER TABLE users
DROP PRIMARY KEY;
----

=== Ограничение `FOREIGN KEY`

`FOREIGN KEY` - это *ключ*, используемый для соединения двух таблиц вместе. Является полем (или набором полей) в одной таблице, которое ссылается на `PRIMARY KEY` в другой таблице.

Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ-кандидат, называется *ссылочной* или *родительской таблицей*.

==== Создание `FOREIGN KEY` при создании таблицы

Следующий SQL-запрос создает `FOREIGN KEY` в столбце `user_id` при создании таблицы `invoice`:

[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
FOREIGN KEY (user_id) REFERENCES users(user_id)
);
----

Чтобы разрешить именовать ограничение `FOREIGN KEY` и определять ограничение `FOREIGN KEY` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
CONSTRAINT FK_UserInvoice FOREIGN KEY (user_id)
REFERENCES Users(user_id)
);
----

====  Создание ограничения `FOREIGN KEY` когда таблица уже создана

Чтобы создать ограничение `FOREIGN KEY` в столбце `user_id`, когда таблица `invoice` уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE invoice
ADD FOREIGN KEY (user_id) REFERENCES Users(user_id);
----

Чтобы разрешить именовать ограничение `FOREIGN KEY` и определять ограничение `FOREIGN KEY` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE invoice
ADD CONSTRAINT FK_UsersInvoice
FOREIGN KEY (user_id) REFERENCES Users(user_id);
----

==== Удаление ограничения `FOREIGN KEY`

Чтобы удалить ограничение `FOREIGN KEY`, используйте следующий:

[source,sql]
----
ALTER TABLE invoice
DROP FOREIGN KEY FK_UsersInvoice;
----

=== Ограничение `CHECK`

Ограничение `CHECK` используется для ограничения диапазона значений, который может быть помещен в столбец. Если определяется ограничение `CHECK` для одного столбца, оно допускает только определенные значения для этого столбца. Если определяется ограничение `CHECK` для таблицы, оно может ограничить значения в определенных столбцах на основе значений в других столбцах в строке.

==== Создание ограничения `CHECK` при создании таблицы

Следующий SQL-запрос создает ограничение `CHECK` в столбце `age`, когда создается таблица «users». Ограничение `CHECK` гарантирует, не может быть пользователя с возрастом старше 60 лет:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
CHECK (age>=60)
);
----

Чтобы разрешить именовать ограничение `CHECK` и определить ограничение `CHECK` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
balance int,
CONSTRAINT CHK_Users CHECK (age>=60 AND balance = 500)
);
----

==== Создание ограничения `CHECK` когда таблица уже создана

Чтобы создать ограничение `CHECK` в столбце `age`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD CHECK (age>=60);
----

Чтобы разрешить именовать ограничение `CHECK` и определить ограничение `CHECK` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT CHK_UsersAge CHECK (age>=60 AND country='Spain');
----

==== `DROP CHECK`

Чтобы удалить ограничение `CHECK`, используйте следующий SQL:

[source,sql]
----
ALTER TABLE users
DROP CHECK CHK_UsersAge;
----

=== Ограничение `DEFAULT`

Ограничение `DEFAULT` используется для предоставления значения по умолчанию для столбца. Значение по умолчанию будет добавлено ко всем новым записям, если другое значение не указано.

==== Установка `DEFAULT` столбца при создании таблицы

Следующий SQL-запрос устанавливает значение `DEFAULT` для столбца `country`, когда создается таблица `users`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
country varchar(255) DEFAULT 'Spain'
);
----

==== Установка `DEFAULT` столбца в уже созданной таблице

Чтобы создать ограничение `DEFAULT` в столбце `country`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ALTER country SET DEFAULT 'Spain';
----

==== Удаление ограничения `DEFAULT`

Чтобы удалить ограничение `DEFAULT`, используйте следующее:

[source,sql]
----
ALTER TABLE users
ALTER country DROP DEFAULT;
----

== Изменение структуры таблицы

Оператор `ALTER TABLE` используется для добавления, удаления или изменения столбцов в существующей таблице, а также для добавления и удаления различных ограничений для существующей таблицы.

=== `ALTER TABLE - ADD Column`

Чтобы добавить столбец в таблицу, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE table_name
ADD column_name datatype;
----

=== `ALTER TABLE - DROP COLUMN`

Чтобы удалить столбец в таблице, используйте следующий синтаксис, обратите внимание, что некоторые системы баз данных не позволяют удалить столбец:

[source,sql]
----
ALTER TABLE table_name
DROP COLUMN column_name;
----

=== `ALTER TABLE - ALTER/MODIFY COLUMN`

Чтобы изменить тип данных столбца в таблице, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
----

[source,sql]
----
ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
----

=== Изменить тип данных

Изменим тип данных столбца с именем `day_birth` в таблице `users`.

[source,sql]
----
ALTER TABLE users
ALTER COLUMN day_birth year;
----

=== Пример `DROP COLUMN`

Для удаления столбца `day_birth` в таблице `users` используется следующее:

[source,sql]
----
ALTER TABLE users
DROP COLUMN day_birth;
----
